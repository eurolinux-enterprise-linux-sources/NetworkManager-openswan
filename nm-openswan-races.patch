From 45961d61692344fe3a99669f939363f130eb48b0 Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@v3.sk>
Date: Tue, 1 Dec 2015 19:05:40 +0100
Subject: [PATCH 1/2] service: wait for pluto to spin up before adding a connection

Libreswan is a bit slower to start than Openswan and we're horribly racy there.

Openswan's "ipsec status" returns incorrect exit status.

Also, there's still 2 sec sleep after we see good status. Pluto spawns some
asynchronous init tasks (adds all connections) upon startup and they might not
have finished and there's no way for us to find out.
---
 src/nm-openswan-service.c |   30 +++++++++++++++++++++++++++++-
 1 files changed, 29 insertions(+), 1 deletions(-)

diff --git a/src/nm-openswan-service.c b/src/nm-openswan-service.c
index aad09f0..c5fa692 100644
--- a/src/nm-openswan-service.c
+++ b/src/nm-openswan-service.c
@@ -247,6 +247,7 @@ nm_openswan_start_openswan_binary (NMOPENSWANPlugin *plugin, GError **error)
 	GPtrArray *openswan_argv;
 	GSource *openswan_watch;
 	gint	stdin_fd;
+	int     retries = 5;
 
 	/* Find openswan ipsec */
 	openswan_binary = openswan_binary_paths;
@@ -287,7 +288,34 @@ nm_openswan_start_openswan_binary (NMOPENSWANPlugin *plugin, GError **error)
 	g_source_attach (openswan_watch, NULL);
 	g_source_unref (openswan_watch);
 
-	sleep(2);
+	openswan_argv = g_ptr_array_new ();
+	/* Just "ipsec status" is not enough, since openswan doesn't
+	 * correctly preserve the exit status... */
+	g_ptr_array_add (openswan_argv, (gpointer) (*openswan_binary));
+	g_ptr_array_add (openswan_argv, (gpointer) "whack");
+	g_ptr_array_add (openswan_argv, (gpointer) "--status");
+	g_ptr_array_add (openswan_argv, NULL);
+	while (1) {
+		gint status;
+
+		if (!g_spawn_sync (NULL, (char **) openswan_argv->pdata, NULL,
+				   0, NULL, NULL, NULL, NULL, &status, error)) {
+			g_ptr_array_free (openswan_argv, TRUE);
+			nm_warning ("failed to check openswan status.  error: '%s'", (*error)->message);
+			return -1;
+		}
+		sleep (2);
+
+		if (status == 0)
+			break;
+		if (retries-- == 0) {
+			g_ptr_array_free (openswan_argv, TRUE);
+			nm_warning ("openswan did not initialize in time.");
+			return -1;
+		}
+		nm_warning ("Retrying the openswan status check...");
+	}
+	g_ptr_array_free (openswan_argv, TRUE);
 
 	openswan_argv = g_ptr_array_new ();
 	g_ptr_array_add (openswan_argv, (gpointer) (*openswan_binary));
-- 
1.7.1

From 894aa7f992d60973717ddd5b2eb7196a5df9931a Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@v3.sk>
Date: Wed, 2 Dec 2015 13:05:39 +0100
Subject: [PATCH 2/2] service: wait for the add to finishe until we proceed up-ting the connection

Also, make sure not to delete secrets too early. There's a 2 sec wait after
up-ping attempt we sort of rely on now. Also, delete it in error handling paths
as well.
---
 src/nm-openswan-service.c |   19 +++++++++++++------
 1 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/src/nm-openswan-service.c b/src/nm-openswan-service.c
index c5fa692..f7a4032 100644
--- a/src/nm-openswan-service.c
+++ b/src/nm-openswan-service.c
@@ -240,9 +240,9 @@ openswan_watch_cb_auto (GPid pid, gint status, gpointer user_data)
 
 static gint
 //nm_openswan_start_openswan_binary (NMSettingVPN *s_vpn, NMOPENSWANPlugin *plugin, GError **error)
-nm_openswan_start_openswan_binary (NMOPENSWANPlugin *plugin, GError **error)
+nm_openswan_start_openswan_binary (NMOPENSWANPlugin *plugin, GError **error, GPid *pid_auto)
 {
-	GPid	pid, pid_auto;
+	GPid	pid;
 	const char **openswan_binary = NULL;
 	GPtrArray *openswan_argv;
 	GSource *openswan_watch;
@@ -331,7 +331,7 @@ nm_openswan_start_openswan_binary (NMOPENSWANPlugin *plugin, GError **error)
 	g_ptr_array_add (openswan_argv, NULL);
 
 	if (!g_spawn_async_with_pipes (NULL, (char **) openswan_argv->pdata, NULL,
-							 G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &pid_auto, &stdin_fd,
+							 G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, pid_auto, &stdin_fd,
 							 NULL, NULL, error)) {
 
 		g_ptr_array_free (openswan_argv, TRUE);
@@ -340,7 +340,7 @@ nm_openswan_start_openswan_binary (NMOPENSWANPlugin *plugin, GError **error)
 	}
 	g_ptr_array_free (openswan_argv, TRUE);
 
-	nm_info ("openswan: ipsec auto started with pid %d", pid_auto);
+	nm_info ("openswan: ipsec auto started with pid %d", *pid_auto);
 
 	/*NM_OPENSWAN_PLUGIN_GET_PRIVATE (plugin)->pid_auto = pid_auto;
 	openswan_watch = g_child_watch_source_new (pid_auto);
@@ -685,6 +685,8 @@ real_connect (NMVPNPlugin   *plugin,
 	NMSettingVPN *s_vpn;
 	gint openswan_fd = -1;
 	gboolean success = FALSE;
+	GPid pid;
+	int status;
 
 	s_vpn = NM_SETTING_VPN (nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN));
 	g_assert (s_vpn);
@@ -698,7 +700,7 @@ real_connect (NMVPNPlugin   *plugin,
 	if (!nm_openswan_config_secret_write (s_vpn, error))
 		goto out;
 
-	openswan_fd = nm_openswan_start_openswan_binary (NM_OPENSWAN_PLUGIN (plugin), error);
+	openswan_fd = nm_openswan_start_openswan_binary (NM_OPENSWAN_PLUGIN (plugin), error, &pid);
 	if (openswan_fd < 0)
 		goto out;
 
@@ -710,7 +712,11 @@ real_connect (NMVPNPlugin   *plugin,
 		openswan_fd=-1;
 	}
 
-	unlink("/etc/ipsec.d/ipsec-nm-conn1.secrets");  
+	waitpid(pid, &status, 0);
+	if (!WIFEXITED (status))
+		goto out;
+	if (WEXITSTATUS(status) != 0)
+		goto out;
 
 	openswan_fd = nm_openswan_start_openswan_connection (NM_OPENSWAN_PLUGIN (plugin), error);
 	if (openswan_fd < 0)
@@ -723,6 +729,7 @@ real_connect (NMVPNPlugin   *plugin,
 	success = TRUE;
 
 out:
+	unlink("/etc/ipsec.d/ipsec-nm-conn1.secrets");
 	if (openswan_fd >= 0)
 		close (openswan_fd);
 
-- 
1.7.1

